"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.City = void 0;
/**
 * City class structure definition.
 */
const country_1 = require("./country");
const util_1 = require("./util");
const cities_json_1 = __importDefault(require("../data/cities.json"));
const continents_json_1 = __importDefault(require("../data/continents.json"));
const city_json_1 = __importDefault(require("../schemas/city.json"));
// The minimum size of a "large" city.
// Large cities are * about 12% of the full database, or ~2926.
const LARGE_CITY_POPULATION = 150000;
class City {
    constructor(latitude, longitude, name, population, timezone, country) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.name = name;
        this.population = population;
        this.timezone = timezone;
        this.country = country;
    }
    static fromRawJson(cityRaw) {
        const country = country_1.Country.getByCountryCode(String(cityRaw[3]));
        return new City(cityRaw[0], cityRaw[1], cityRaw[2], cityRaw[4], cityRaw[5], country);
    }
    /**
     * Look up all of the cities matching a name. This can be used for partial matching
     * such as in an look up form field.
     */
    static getAllByName(name, countryCode) {
        const matcher = new RegExp(name, 'i');
        let found = cities_json_1.default;
        if (countryCode) {
            found = found.filter(city => (city[3] === countryCode));
        }
        found = found.filter(city => (String(city[2]).match(matcher)));
        return found.map(City.fromRawJson);
    }
    /**
     * Look up a city by name, returning the first one that matches.
     * Optionally also filter on country code.
     */
    static getByName(name, countryCode) {
        const matcher = new RegExp(name, 'i');
        for (let i = 0; i < cities_json_1.default.length; i++) {
            if (countryCode && cities_json_1.default[i][3] !== countryCode) {
                continue;
            }
            if (String(cities_json_1.default[i][2]).match(matcher)) {
                return City.fromRawJson(cities_json_1.default[i]);
            }
        }
        return undefined;
    }
    /**
     * Getter for the nested Country object that returns the full object with
     * geoJSON and flag SVG.
     */
    getCountry() {
        return country_1.Country.getByCountryCode(this.country.countryCode, true);
    }
    /**
     * Get the largest cities. Optionally filter by continent. Optionally speficify
     * the number of largest cities you want, default 10.
     *
     * @param continent One of the 7 (really 6)
     * @param count The number of top largest cities.
     */
    static getLargestCities(continent, count = 10) {
        let sorted = cities_json_1.default;
        if (continent) {
            const global = continents_json_1.default;
            sorted = sorted.filter(city => (global[continent].includes(city[3])));
        }
        sorted.sort((a, b) => (b[4] - a[4]));
        return sorted.slice(0, count).map(City.fromRawJson);
    }
    /**
     * Get the city nearest to the GPS coordinates, as determined by the distance,
     * as the crow flies.
     */
    static getNearest(lat, lng) {
        // Nothing can be further than the circumference of the earth, use this as the maximum bound.
        let distance = 4e7;
        let city = cities_json_1.default[0];
        let d;
        // Using a `for` loop performed 13.4% faster and 18.8% less memory than `cities.forEach`
        for (let i = 0; i < cities_json_1.default.length; i++) {
            d = util_1.getDistance(lat, lng, Number(cities_json_1.default[i][0]), Number(cities_json_1.default[i][1]));
            if (d < distance) {
                distance = d;
                city = cities_json_1.default[i];
            }
        }
        ;
        return City.fromRawJson(city);
    }
    /**
     * Get the country nearest to the GPS coordinates, as determined by the distance,
     * as the crow flies.
     */
    static getNearestCountry(lat, lng) {
        return City.getNearest(lat, lng).getCountry();
    }
    /**
     * Get the nearest large city.
     */
    static getNearestLargeCity(lat, lng) {
        let distance = 4e7;
        let city = cities_json_1.default[0];
        let d;
        // Using a `for` loop performed 13.4% faster and 18.8% less memory than `cities.forEach`
        for (let i = 0; i < cities_json_1.default.length; i++) {
            if (cities_json_1.default[i][4] > LARGE_CITY_POPULATION) {
                d = util_1.getDistance(lat, lng, Number(cities_json_1.default[i][0]), Number(cities_json_1.default[i][1]));
                if (d < distance) {
                    distance = d;
                    city = cities_json_1.default[i];
                }
            }
        }
        ;
        return City.fromRawJson(city);
    }
    static get schema() {
        return city_json_1.default;
    }
}
exports.City = City;
